require 'yaml'
require 'stackmate'

class StackMate::CloudStackResource
  def logger
    ::Rails.logger
  end
  def on_reply(work_item)
    logger.debug "In Stacktician::on_reply #{@opts.inspect}"
    #save the physical id generated by on_workitem to the database row for the corresponding
    #stack_resource
    begin
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        resource = stack.stack_resources.find_by_logical_id(work_item.participant_name)
        #avoid undefined nil class error if work_item is messed up
        if "create".eql?(work_item["params"]["operation"])
          resource.physical_id = work_item[work_item.participant_name]['physical_id']
          resource.status = 'CREATE_COMPLETE'
        elsif "rollback".eql?(work_item["params"]["operation"])
          #dont alter resource id.
          if(!resource.physical_id.nil?)
            resource.status = "DELETE_COMPLETE"
          else
            resource.status = "NOT_CREATED"
          end
        end
        resource.save
      end
    rescue Exception => e
      #dont propogate error since it may be raised during rollback too, and hence kill the ruote engine
      logger.error("Unable to change resource status for #{work_item.participant_name} : " + e.message)
    end
  end
end

class StackMate::CloudStackOutput
  def initialize(opts)
    @opts = opts
  end

  def logger
    ::Rails.logger
  end
  #mark the stack execution as complete and update the db with the outputs
  def on_reply(work_item)
    p "In outputs"
    outputs = work_item['Outputs']
    logger.debug "In Stacktician::CloudStackOutput.on_reply #{outputs.inspect}"
    ActiveRecord::Base.connection_pool.with_connection do
      stack = Stack.find(@opts['stack_id'])
      outputs.each do |key, val|
        logger.debug "Output: key = #{key}, value = #{val}"
        stack_output = stack.stack_outputs.find_by_key(key)
        stack_output.value = val
        stack_output.save
      end
      stack.status = 'CREATE_COMPLETE'
      stack.save
    end
  end
end

#Noop case
class StackMate::Output
  def initialize(opts)
    @opts = opts
  end

  def logger
    ::Rails.logger
  end
  #mark the stack execution as complete and update the db with the outputs
  def on_reply(work_item)
    p "In outputs"
    outputs = work_item['Outputs']
    logger.debug "In Stacktician::Output.on_reply #{outputs.inspect}"
    ActiveRecord::Base.connection_pool.with_connection do
      stack = Stack.find(@opts['stack_id'])
      outputs.each do |key, val|
        v = val['Value']
        logger.debug "Output: key = #{key}, value = #{v}"
        stack_output = stack.stack_outputs.find_by_key(key)
        stack_output.value = v
        stack_output.save
      end
      stack.status = 'CREATE_COMPLETE'
      stack.save
    end
  end
end

module Stacktician
  # Use this to override existing (e.g., stackmate's) resource
  # so that we can save the physical id to  the database
  # use include Participants
  module Participants

    def logger
      ::Rails.logger
    end

    # substitute for stackmate's resources with overriden classes
    # e.g, StackMate::NoOpResource gets replaced by Stacktician::NoOpResource
    def Participants.class_for(cf_resource)
      c = StackMate.class_for(cf_resource)
      c.gsub!('StackMate', 'Stacktician') if (c.include?("WaitCondition") || c.include?("NoOp"))
      c
      #cf_resource
    end

    #callback triggered from Ruote whenever a participant calls reply(engine)
    def on_reply(work_item)
      logger.debug "In Stacktician::on_reply #{@opts.inspect}"
      #save the physical id generated by on_workitem to the database row for the corresponding
      #stack_resource
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        resource = stack.stack_resources.find_by_logical_id(@opts['participant'])
        resource.status = 'CREATE_COMPLETE'
        #logger.info "#{work_item[@opts['participant']].inspect}"
        resource.physical_id = work_item[@opts['participant']]['physical_id']
        resource.save
      end
    end

  end


  class NoOpResource < StackMate::NoOpResource
    include Participants

    def initialize(opts)
      @opts = opts
    end

  end

  #Noop output
  class Output < StackMate::Output

    def initialize(opts)
      @opts = opts
    end

    def logger
      ::Rails.logger
    end

    def on_reply
      outputs = workitem.fields['Outputs']
      logger.debug "In Stacktician::Output.on_workitem #{outputs.inspect}"
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        outputs.each do |key, val|
          v = val['Value']
          logger.debug "Output: key = #{key}, value = #{v} descr = #{val['Description']}"
          stack_output = stack.stack_outputs.find_by_key(key)
          stack_output.value = v
          stack_output.save
        end
        stack.status = 'CREATE_COMPLETE'
        stack.save
      end
    end

  end

  class CloudStackInstance < StackMate::CloudStackInstance
    include Participants

    def initialize(opts)
      @opts = opts
      super(opts)
    end

    #override to read this from the environment
    #this way if deployed in Heroku, we can use Foreman
    #to set these mappings
    def load_local_mappings()
      begin
        @localized = YAML.load(ENV['CS_LOCAL'])
      rescue
        logger.warn "Warning: Failed to load localized mappings from environment var CS_LOCAL"
      end
    end

  end

  class CloudStackSecurityGroupAWS < StackMate::CloudStackSecurityGroupAWS
    include Participants

    def initialize(opts)
      @opts = opts
      super(opts)
    end

  end

  # Use Ruote::StorageParticipant since it lets us 'reply_to_engine' at a
  # later time.
  class WaitCondition < Ruote::StorageParticipant

    def logger
      ::Rails.logger
    end

    def initialize(opts)
      @opts = opts
    end

    def on_workitem
      logger.debug "Entering  #{participant_name} in #{workitem.fei.wfid}"
      # WaitConditionHandle refers to its WaitHandle with a Ref:
      #"Properties" : {
      # "Handle" : {"Ref" : "WaitHandle"},
      # "Timeout" : "300"
      #
      workitem[participant_name] = {}
      props = workitem.fields['Resources'][participant_name]['Properties']
      logger.debug "#{props.inspect}"
      wait_handle_name = props['Handle']['Ref']
      workitem[participant_name][:physical_id] = workitem.fields['ResolvedNames'][wait_handle_name]
      #save the physical id as the same as the url generated by the wait handle participant
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        resource = stack.stack_resources.find_by_logical_id(@opts['participant'])
        resource.physical_id = workitem.fields['ResolvedNames'][wait_handle_name]
        resource.save
      end
      super
    end

  end

  #generates the wait condition url and stores it as 'physical_id'
  class WaitConditionHandle < Ruote::Participant
    include Participants

    def logger
      ::Rails.logger
    end

    def initialize(opts)
      @opts = opts
    end

    def on_workitem
      logger.debug "Entering #{participant_name} in #{workitem.fei.wfid}"
      workitem[participant_name] = {}
      base_url = Stacktician::CONFIG[:wait_condition_base_url]
      presigned_url = base_url + workitem.fei.wfid + '/' + participant_name
      #TODO actually sign it
      #TODO include stack id in URL
      workitem.fields['ResolvedNames'][participant_name] = presigned_url
      workitem[participant_name][:physical_id] = presigned_url
      logger.debug "Pre-signed URL is: #{presigned_url} "
      logger.debug "Try: \ncurl -X PUT --data 'foo' #{presigned_url}"
      reply
    end

  end

  class CloudStackOutput < StackMate::CloudStackOutput

    def initialize(opts)
      @opts = opts
    end

    def logger
      ::Rails.logger
    end

    #mark the stack execution as complete and update the db with the outputs
    def on_reply
      outputs = workitem.fields['Outputs']
      logger.debug "In Stacktician::CloudStackOutput.on_reply #{outputs.inspect}"
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        outputs.each do |key, val|
          logger.debug "Output: key = #{key}, value = #{val} "
          stack_output = stack.stack_outputs.find_by_key(key)
          stack_output.value = val
          stack_output.save
        end
        stack.status = 'CREATE_COMPLETE'
        stack.save
      end
    end

  end
end
